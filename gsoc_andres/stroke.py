from kivy.properties import (NumericProperty, ListProperty, BooleanProperty,
                             DictProperty)


from kivy.graphics import Color
from enum import Enum, unique
from stroke_rect import StrokeRect
from stroke_point import StrokePoint
from math import sqrt

class Stroke(object):

    '''
    Stroke
    ===================

    This class allows you to easily manipulate points on
    an InkCanvas, handles some drawing attributes and methods
    to perform changes on the points::

        # Create a Stroke and modify attributes
        stroke = Stroke(group_id=g)
        stroke.color = Stroke.Color.Yellow
        stroke.isHighlighter(0.5)
        stroke.points.append(StrokePoint(touch.x, touch.y))

    .. warning::

        You won't really instantiate Strokes: it's more an example how
        InkCanvas handle strokes. Typically, you would use the list of strokes
        generated by InkCanvas for further processing.

    '''

    '''Default Constructor'''
    def __init__(self, group_id=""):
        self.points = []
        self.color = self.Color.Black
        self.point_size = 1
        self.group_id = group_id
        self.graphics_points = []
        self.sampled_points = []

    def __eq__(self, other):
        '''Override default Equals behaviour'''
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        return False

    def __ne__(self, other):
        '''Define a non equality test'''
        return not self.__eq__(other)

    def __str__(self):
        '''String representation'''
        cad = "["
        for point in self.points:
            cad += "(%s, %s)," % (point.X, point.Y)
        return cad[:-1] + "]"

    def __repr__(self):
        '''print StrokePoint'''
        cad = "<%s> [" % (self.__class__.__name__)
        for point in self.points:
            cad += "(%r, %r)," % (point.X, point.Y)
        return cad[:-1] + "]"

    def is_highlighter(self, alfa):
        self.color = self.color + (alfa,)

    def hit_test(self, p):
        for point in self.points:
            dist = point.distance_to(p)
            if dist < 5.0:
                return True
        return False
    
    def get_bounds(self):
        minx = float("inf")
        maxx = float(0)
        miny = float("inf")
        maxy = float(0)
        for point in self.points:
            if point.X < minx:
                minx = point.X
            if point.X > maxx:
                maxx = point.X
            if point.Y < miny:
                miny = point.Y
            if point.Y > maxy:
                maxy = point.Y
        return StrokeRect(StrokePoint(minx,maxy), StrokePoint(maxx,miny))

    def sampling1(self):
        for i in range(1, len(self.points) - 1):
            list_new_points = self.calculate2points(self.points[i-1], self.points[i])
            self.graphics_points.extend(list_new_points)
            self.sampled_points.extend(list_new_points)

    def sampling2(self):
        bounds = self.get_bounds()
        S = bounds.top_left().distance_to(bounds.bottom_right()) / 40.0;
        D = 0.0
        self.sampled_points.append(self.points[0])
        for i in range(1, len(self.points) - 1):
            d = self.points[i-1].distance_to(self.points[i]) # euclidean distance
            if (D+d) >= S:
                q = StrokePoint(-1,-1)
                q.X = self.points[i-1].X + ((S - D) / d) * (self.points[i].X - self.points[i-1].X)
                q.Y = self.points[i-1].Y + ((S - D) / d) * (self.points[i].Y - self.points[i-1].Y)
                self.sampled_points.append(q)
                D = 0.0
            else:
                D = D + d

    def calculate2points(self, point1, point2, steps=5):
        dx = point2.X - point1.X
        dy = point2.Y - point1.Y
        dist = sqrt(dx * dx + dy * dy)
        if dist < steps:
            return None
        o = []
        m = dist / steps
        for i in range(1, int(m)):
            mi = i / m
            lastx = point1.X + dx * mi
            lasty = point1.Y + dy * mi
            o.extend([lastx, lasty])
        return o

    def get_line_points(self):
        linepoints = []
        for point in self.sampled_points:
            linepoints.extend([float(point.X), float(point.Y)])
        return linepoints
    
    class Color(object):
        '''Values for different colors so a Stroke can
        change its color by name, rather than a tuple
        '''
        AliceBlue = (0.941176, 0.972549, 1)
        AntiqueWhite = (0.980392, 0.921569, 0.843137)
        AquaMarine = (0.498039, 1, 0.831373)
        Azure = (0.941176, 1, 1)
        Beige = (0.960784, 0.960784, 0.862745)
        Black = (0, 0, 0)
        Blue = (0, 0, 1)
        BlueViolet = (0.541176, 0.168627, 0.886275)
        Brown = (0.647059, 0.164706, 0.164706)
        Cyan = (0, 1, 1)
        DarkBlue = (0, 0, 0.545098)
        DarkCyan = (0, 0.545098, 0.545098)
        Green = (0, 1, 0)
        Grey = (0.745098, 0.745098, 0.745098)
        Indigo = (0.294118, 0, 0.509804)
        Yellow = (1, 1, 0)
        White = (1, 1, 1)
