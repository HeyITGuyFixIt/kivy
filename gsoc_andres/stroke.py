from kivy.properties import (NumericProperty, ListProperty, BooleanProperty,
                             DictProperty)


from kivy.graphics import Color
from enum import Enum, unique
from stroke_rect import StrokeRect
from stroke_point import StrokePoint
from math import sqrt

class Stroke(object):

    '''
    Stroke
    ===================

    This class allows you to easily manipulate points on
    an InkCanvas, handles some drawing attributes and methods
    to perform changes on the points::

        # Create a Stroke and modify attributes
        stroke = Stroke(group_id=g)
        stroke.color = Stroke.Color.Yellow
        stroke.isHighlighter(0.5)
        stroke.points.append(StrokePoint(touch.x, touch.y))

    .. warning::

        You won't really instantiate Strokes: it's more an example how
        InkCanvas handle strokes. Typically, you would use the list of strokes
        generated by InkCanvas for further processing.

    '''

    '''Default Constructor'''
    def __init__(self, group_id="", shortstraw_const=40.0):
        self.points = []
        self.color = self.Color.Black
        self.group_id = group_id
        self.sampled_points = []

    def __eq__(self, other):
        '''Override default Equals behaviour'''
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        return False

    def __ne__(self, other):
        '''Define a non equality test'''
        return not self.__eq__(other)

    def __str__(self):
        '''String representation'''
        cad = "["
        for point in self.points:
            cad += "(%s, %s)," % (point.X, point.Y)
        return cad[:-1] + "]"

    def __repr__(self):
        '''print StrokePoint'''
        cad = "<%s> [" % (self.__class__.__name__)
        for point in self.points:
            cad += "(%r, %r)," % (point.X, point.Y)
        return cad[:-1] + "]"

    def is_highlighter(self, alfa):
        if(len(self.color) == 4):
            self.color = (self.color[0], self.color[1], self.color[2])
        self.color = self.color + (alfa,)

    def visibility(self, visible):
        alfa = 1
        if len(self.color) == 4:
            alfa = self.color[3]
            self.color = (self.color[0], self.color[1], self.color[2])
        if not visible:
            self.color = self.color + (0,)
        else:
            self.color = self.color + (alfa,)

    def hit_test(self, p):
        for point in self.points:
            dist = point.distance_to(p)
            if dist < 5.0:
                return True
        return False
    
    def get_bounds(self):
        minx = float("inf")
        maxx = float(0)
        miny = float("inf")
        maxy = float(0)
        for point in self.points:
            if point.X < minx:
                minx = point.X
            if point.X > maxx:
                maxx = point.X
            if point.Y < miny:
                miny = point.Y
            if point.Y > maxy:
                maxy = point.Y
        return StrokeRect(StrokePoint(minx,maxy), StrokePoint(maxx,miny))

    def sample_points(self):
        bounds = self.get_bounds()
        S = bounds.top_left().distance_to(bounds.bottom_right()) / 40.0;
        D = 0.0
        self.sampled_points.append(self.points[0])
        clone_points = self.points[:]
        for i, point in enumerate(clone_points):
            if i > 0:
                d = clone_points[i-1].distance_to(clone_points[i]) # euclidean distance
                if (D+d) >= S:
                    q = StrokePoint(-1,-1)
                    q.X = clone_points[i-1].X + ((S - D) / d) * (clone_points[i].X - clone_points[i-1].X)
                    q.Y = clone_points[i-1].Y + ((S - D) / d) * (clone_points[i].Y - clone_points[i-1].Y)
                    self.sampled_points.append(q)
                    clone_points.insert(i, q)
                    D = 0.0
                else:
                    D = D + d

    def get_graphics_line_points(self):
        linepoints = []
        for point in self.sampled_points:
            linepoints.extend([float(point.X), float(point.Y)])
        return linepoints
    
    class Color(object):
        '''Values for different colors so a Stroke can
        change its color by name, rather than a tuple
        '''
        AliceBlue = (0.941176, 0.972549, 1)
        AntiqueWhite = (0.980392, 0.921569, 0.843137)
        AquaMarine = (0.498039, 1, 0.831373)
        Azure = (0.941176, 1, 1)
        Beige = (0.960784, 0.960784, 0.862745)
        Black = (0, 0, 0)
        BlanchedAlmond = (1, 0.921569, 0.803922)
        Blue = (0, 0, 1)
        BlueViolet = (0.541176, 0.168627, 0.886275)
        Brown = (0.647059, 0.164706, 0.164706)
        BurlyWood = (0.870588, 0.721569, 0.529412)
        CadetBlue = (0.372549, 0.619608, 0.627451)
        ChartReuse = (0.498039, 1, 0)
        Chocolate = (0.823529, 0.411765, 0.117647)
        Coral = (1, 0.498039, 0.313725)
        CornFlowerBlue = (0.392157, 0.584314, 0.929412)
        CornSilk = (1, 0.972549, 0.862745)
        Cyan = (0, 1, 1)
        DarkBlue = (0, 0, 0.545098)
        DarkCyan = (0, 0.545098, 0.545098)
        Green = (0, 1, 0)
        Grey = (0.745098, 0.745098, 0.745098)
        Indigo = (0.294118, 0, 0.509804)
        Yellow = (1, 1, 0)
        White = (1, 1, 1)
